<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Doom-ish Raycasting Demo (HTML)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:system-ui,Arial}
  #container{display:flex;height:100vh;align-items:stretch}
  canvas{display:block;background:#666;flex:1}
  #ui{width:340px;padding:12px;background:#0b0b0b;border-left:2px solid #151515;box-sizing:border-box}
  h1{margin:0 0 8px 0;font-size:18px}
  p{margin:6px 0;color:#bbb;font-size:13px}
  .kbd{display:inline-block;padding:2px 6px;border-radius:4px;background:#222;border:1px solid #2a2a2a;color:#fff;font-weight:600}
  footer{font-size:12px;color:#9a9a9a;margin-top:12px}
  #legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .stat{background:#111;padding:8px;border-radius:6px;border:1px solid #212121}
</style>
</head>
<body>
<div id="container">
  <canvas id="view"></canvas>
  <div id="ui">
    <h1>Doom-ish Raycaster (HTML)</h1>
    <p>A compact, single-file raycasting demo approximating classic pseudo-3D. No assets required.</p>
    <div id="legend">
      <div class="stat"><strong>W/A/S/D</strong><div style="font-size:12px">Move</div></div>
      <div class="stat"><strong>Q/E ←→</strong><div style="font-size:12px">Rotate</div></div>
      <div class="stat"><strong>Space</strong><div style="font-size:12px">Shoot</div></div>
      <div class="stat"><strong>M</strong><div style="font-size:12px">Toggle minimap</div></div>
    </div>
    <p style="margin-top:12px">Tip: run fullscreen (F11) for a better experience.</p>
    <p id="info"></p>
    <footer>Procedural textures • Simple enemy sprites • Minimal physics</footer>
  </div>
</div>

<script>
(() => {
  // Canvas setup
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', {alpha:false});
  let W = canvas.width = Math.floor(window.innerWidth - 340);
  let H = canvas.height = window.innerHeight;
  window.addEventListener('resize', () => {
    W = canvas.width = Math.max(400, Math.floor(window.innerWidth - 340));
    H = canvas.height = window.innerHeight;
  });

  const info = document.getElementById('info');

  // Map config (1 = wall, 0 = empty)
  const MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,2,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,3,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,2,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,3,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,2,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1],
  ];
  const ROWS = MAP.length;
  const COLS = MAP[0].length;
  const TILE = 64;

  // Player
  const player = {
    x: TILE * 1.5,
    y: TILE * 1.5,
    angle: 0.0,
    speed: 140, // units/s
    rotSpeed: Math.PI, // rad/s
    radius: 8,
    health: 100
  };

  // Enemies (x,y in world coords)
  const enemies = [
    {x: TILE*8.5, y: TILE*3.5, hp: 30, dir: 1},
    {x: TILE*4.5, y: TILE*5.5, hp: 30, dir: -1},
    {x: TILE*7.2, y: TILE*6.6, hp: 30, dir: 1},
  ];

  let showMap = true;

  // View settings
  const FOV = (60 * Math.PI / 180);
  const HALF_FOV = FOV/2;
  const NUM_RAYS = Math.floor(W / 2); // one ray per 2 pixels (balance perf)
  const MAX_DEPTH = 1000;

  // Textures: procedurally create a few texture canvases
  function makeTexture(seedColor, stripe=false) {
    const c = document.createElement('canvas');
    c.width = 64; c.height = 64;
    const g = c.getContext('2d');
    // base
    g.fillStyle = seedColor; g.fillRect(0,0,64,64);
    // noise
    const img = g.createImageData(64,64);
    for(let i=0;i<img.data.length;i+=4){
      const v = 20 + Math.floor(Math.random()*45);
      img.data[i]=v; img.data[i+1]=v; img.data[i+2]=v; img.data[i+3]=120;
    }
    g.putImageData(img,0,0);
    // optional stripe
    if (stripe) {
      g.fillStyle = 'rgba(0,0,0,0.12)';
      for(let x=0;x<64;x+=8) g.fillRect(x,0,4,64);
    }
    return c;
  }
  const textures = {
    1: makeTexture('#9a6b4b', true),
    2: makeTexture('#4b8a9a', true),
    3: makeTexture('#7a4b9a', false),
  };
  // simple enemy sprite
  const enemySprite = (() => {
    const c = document.createElement('canvas'); c.width = 64; c.height = 64;
    const g = c.getContext('2d');
    // red circle with eye
    g.fillStyle='#b02a2a'; g.beginPath(); g.ellipse(32,32,28,28,0,0,Math.PI*2); g.fill();
    g.fillStyle='#ffcdcd'; g.beginPath(); g.ellipse(41,25,6,6,0,0,Math.PI*2); g.fill();
    g.fillStyle='#3a0a0a'; g.beginPath(); g.ellipse(41,25,2,2,0,0,Math.PI*2); g.fill();
    return c;
  })();

  // Key handling
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === 'm' || e.key === 'M') showMap = !showMap;
  });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  // Utility: map check
  function mapAt(x,y){
    if (x < 0 || y < 0) return 1;
    const mx = Math.floor(x / TILE), my = Math.floor(y / TILE);
    if (my < 0 || my >= ROWS || mx < 0 || mx >= COLS) return 1;
    return MAP[my][mx];
  }

  // Collision detect for player movement
  function collides(x,y){
    // sample four points around player
    const r = player.radius;
    const points = [
      [x - r, y - r], [x + r, y - r],
      [x - r, y + r], [x + r, y + r]
    ];
    return points.some(p => mapAt(p[0], p[1]) !== 0);
  }

  // Raycasting (DDA per ray)
  function castRay(rayAngle){
    // normalize angle
    let angle = rayAngle % (Math.PI*2);
    if (angle < 0) angle += Math.PI*2;

    // ray direction
    const sin = Math.sin(angle), cos = Math.cos(angle);

    // step along ray and check for wall hit
    let distance = 0;
    let hit = null;
    while (distance < MAX_DEPTH) {
      distance += 2; // step size
      const px = player.x + cos * distance;
      const py = player.y + sin * distance;
      const m = mapAt(px, py);
      if (m !== 0) {
        // determine texture x offset (for slanted look)
        const blockX = Math.floor(px / TILE) * TILE;
        const blockY = Math.floor(py / TILE) * TILE;
        // which side? check nearer to grid lines
        const localX = px - blockX;
        const localY = py - blockY;
        let texX;
        if (Math.abs(localX - 0) < 1 || Math.abs(localX - TILE) < 1) texX = localY;
        else texX = localX;
        hit = {dist: distance, x:px, y:py, tex: m, texX: texX};
        break;
      }
    }
    return hit || {dist: MAX_DEPTH, x:player.x + cos*MAX_DEPTH, y:player.y + sin*MAX_DEPTH, tex:1, texX:0};
  }

  // Draw loop
  let last = performance.now();
  function frame(now){
    const dt = (now - last) / 1000; last = now;
    update(dt);
    render();
    requestAnimationFrame(frame);
  }

  // Update game state
  function update(dt){
    // Rotation
    if (keys['q'] || keys['arrowleft']) player.angle -= player.rotSpeed * dt;
    if (keys['e'] || keys['arrowright']) player.angle += player.rotSpeed * dt;

    // Movement
    let moveX = 0, moveY = 0;
    const forward = (keys['w'] ? 1 : 0) - (keys['s'] ? 1 : 0);
    const strafe = (keys['d'] ? 1 : 0) - (keys['a'] ? 1 : 0);
    if (forward !== 0) {
      moveX += Math.cos(player.angle) * forward * player.speed * dt;
      moveY += Math.sin(player.angle) * forward * player.speed * dt;
    }
    if (strafe !== 0) {
      moveX += Math.cos(player.angle + Math.PI/2) * strafe * player.speed * dt;
      moveY += Math.sin(player.angle + Math.PI/2) * strafe * player.speed * dt;
    }
    // attempt movement with collision
    const tryX = player.x + moveX, tryY = player.y + moveY;
    if (!collides(tryX, player.y)) player.x = tryX;
    if (!collides(player.x, tryY)) player.y = tryY;

    // Enemies: simple back-and-forth movement within their tile
    for (const e of enemies){
      if (e.hp <= 0) continue;
      // simple patrol: move along x or y depending on initial dir
      const speed = 30;
      e.x += Math.cos(performance.now()/1000 + e.dir) * 0.4;
      e.y += Math.sin(performance.now()/1000 + e.dir) * 0.3;
      // clamp inside map bounds
      e.x = Math.max(TILE+8, Math.min(COLS*TILE-TILE-8, e.x));
      e.y = Math.max(TILE+8, Math.min(ROWS*TILE-TILE-8, e.y));
    }

    // Shooting
    if (keys[' ']) {
      // instant hit-scan: cast a narrow cone of rays to find enemy
      const shootAngle = player.angle;
      let hitEnemy = null;
      let minDist = Infinity;
      for (const e of enemies){
        if (e.hp <= 0) continue;
        const dx = e.x - player.x, dy = e.y - player.y;
        const dist = Math.hypot(dx,dy);
        const ang = Math.atan2(dy,dx);
        let da = ang - shootAngle;
        da = ((da + Math.PI) % (2*Math.PI)) - Math.PI; // normalize
        if (Math.abs(da) < 0.06 && dist < 600) {
          if (dist < minDist) { minDist = dist; hitEnemy = e; }
        }
      }
      if (hitEnemy) {
        // apply damage (once per press)
        if (!keys.__spaceHandled) {
          hitEnemy.hp -= 20;
          keys.__spaceHandled = true;
        }
      } else {
        // mark handled so we don't rapid-fire by holding space
        if (!keys.__spaceHandled) keys.__spaceHandled = true;
      }
    } else {
      keys.__spaceHandled = false;
    }

    // Info text
    info.textContent = `Pos: ${player.x.toFixed(1)}, ${player.y.toFixed(1)}  Angle: ${(player.angle%(Math.PI*2)).toFixed(2)}  Enemies alive: ${enemies.filter(e=>e.hp>0).length}`;
  }

  // Render scene
  function render(){
    // setup
    ctx.clearRect(0,0,W,H);

    // Draw ceiling
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(0,0,W, H/2);
    // Draw floor
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0,H/2,W, H/2);

    // Raycast columns
    const stripWidth = W / NUM_RAYS;
    const halfH = H/2;
    for (let i=0;i<NUM_RAYS;i++){
      const cameraX = (2 * i / NUM_RAYS) - 1; // -1 .. 1
      const rayAngle = player.angle + Math.atan(cameraX * Math.tan(HALF_FOV));
      const hit = castRay(rayAngle);

      // correct fish-eye
      const ca = Math.cos(rayAngle - player.angle);
      const dist = Math.max(0.0001, hit.dist * ca);

      // wall height projection
      const proj = (TILE / dist) * (W / 3); // arbitrary projection scale
      const wallHeight = Math.min(H*2, proj);
      const top = Math.floor(halfH - wallHeight/2);
      const bottom = Math.floor(halfH + wallHeight/2);

      // sample texture column from procedural texture
      const tex = textures[hit.tex] || textures[1];
      const texWidth = tex.width, texHeight = tex.height;
      // map texX (0..TILE)
      const xOff = Math.floor((hit.texX / TILE) * texWidth) % texWidth;
      // draw vertical slice by drawing portion of texture scaled to wallHeight
      ctx.drawImage(tex, xOff,0,1,texHeight, i*stripWidth, top, stripWidth, wallHeight);

      // simple shading: farther walls darker
      const shade = Math.max(0.25, 1 - dist / 700);
      ctx.fillStyle = `rgba(0,0,0,${1-shade})`;
      ctx.fillRect(i * stripWidth, top, stripWidth, wallHeight);

      // floor shading gradient per column
      // we leave floor/ceiling simple to keep perf acceptable
    }

    // Draw simple sprites for enemies (billboarding)
    for (const e of enemies){
      if (e.hp <= 0) continue;
      const dx = e.x - player.x, dy = e.y - player.y;
      const dist = Math.hypot(dx,dy);
      if (dist < 10) continue;
      const ang = Math.atan2(dy,dx);
      let da = ang - player.angle;
      da = ((da + Math.PI) % (2*Math.PI)) - Math.PI;
      if (Math.abs(da) > HALF_FOV + 0.2) continue; // off-screen

      // screen position
      const rel = Math.tan(da) / Math.tan(HALF_FOV); // -1..1
      const screenX = (W/2) + rel * (W/2);
      // size = scale by distance
      const size = Math.max(8, (TILE / dist) * (W/2));
      const sx = screenX - size/2;
      const sy = (H/2) - size/2;

      // draw sprite with distance-based darkening
      ctx.save();
      ctx.globalAlpha = Math.max(0.2, 1 - dist / 900);
      ctx.drawImage(enemySprite, sx, sy, size, size);
      ctx.restore();
    }

    // HUD
    // crosshair
    ctx.fillStyle = '#fff';
    ctx.fillRect(W/2 - 1, H/2 - 12, 2, 24);
    ctx.fillRect(W/2 - 12, H/2 - 1, 24, 2);

    // minimap
    if (showMap) drawMiniMap();
  }

  function drawMiniMap(){
    const mmScale = 0.9 * Math.min(300 / (COLS*TILE), 300 / (ROWS*TILE));
    const mmW = COLS * TILE * mmScale, mmH = ROWS * TILE * mmScale;
    const pad = 10;
    const mmX = W - mmW - pad - 8;
    const mmY = pad;

    // background
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(mmX - 6, mmY - 6, mmW + 12, mmH + 12);
    // tiles
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const v = MAP[r][c];
        if (v === 0) ctx.fillStyle = '#2a2a2a';
        else if (v === 1) ctx.fillStyle = '#9a6b4b';
        else if (v === 2) ctx.fillStyle = '#4b8a9a';
        else ctx.fillStyle = '#7a4b9a';
        ctx.fillRect(mmX + c*TILE*mmScale, mmY + r*TILE*mmScale, TILE*mmScale, TILE*mmScale);
      }
    }

    // player on map
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(mmX + player.x*mmScale, mmY + player.y*mmScale, 4, 0, Math.PI*2);
    ctx.fill();
    // facing vector
    ctx.strokeStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(mmX + player.x*mmScale, mmY + player.y*mmScale);
    ctx.lineTo(mmX + (player.x + Math.cos(player.angle)*20)*mmScale, mmY + (player.y + Math.sin(player.angle)*20)*mmScale);
    ctx.stroke();

    // enemies
    for (const e of enemies){
      if (e.hp <= 0) continue;
      ctx.fillStyle = '#d14a4a';
      ctx.beginPath();
      ctx.arc(mmX + e.x*mmScale, mmY + e.y*mmScale, 5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Start animation
  requestAnimationFrame(frame);

  // Helpful: show the HTML file note in console
  console.log('Doom-ish raycasting demo loaded. Save as doomish.html and open in browser.');
})();
</script>
</body>
</html>
